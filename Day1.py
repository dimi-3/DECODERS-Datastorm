# -*- coding: utf-8 -*-
"""internalDataStrom.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dXdw0bHztQuV-OVEAWp0NeOhRmmrEz7-
"""

from google.colab import drive
drive.mount('/content/gdrive')

# Importing libraries for building the neural network
import tensorflow as tf
import pandas as pd
import io
import numpy as np
from sklearn.model_selection import train_test_split,StratifiedKFold,cross_val_score,RandomizedSearchCV
from sklearn.preprocessing import LabelEncoder,StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.ensemble.forest import RandomForestClassifier
from sklearn.feature_selection import SelectFromModel
from sklearn.metrics import classification_report, confusion_matrix
from google.colab import files

data = pd.read_csv("/content/gdrive/My Drive/data-storm-10/credit_card_default_train.csv").dropna()
test = pd.read_csv("/content/gdrive/My Drive/data-storm-10/credit_card_default_test.csv").dropna()
print(data.shape)
print(test.shape)
print(list(data.columns))
print(list(test.columns))
data.head(n=3)

# prediction_var = ['Gender', 'EDUCATION_STATUS', 'MARITAL_STATUS', 
#            'PAY_JULY', 'PAY_AUG', 'PAY_SEP', 'PAY_OCT', 'PAY_NOV', 'PAY_DEC',
#            'DUE_AMT_JULY', 'DUE_AMT_AUG', 'DUE_AMT_SEP','DUE_AMT_OCT','DUE_AMT_NOV','DUE_AMT_DEC', 'PAID_AMT_JULY', 'PAID_AMT_AUG', 'PAID_AMT_SEP', 'PAID_AMT_OCT', 'PAID_AMT_NOV', 'PAID_AMT_DEC']
prediction_var = ['Balance_Limit_V1', 'Gender', 'EDUCATION_STATUS', 'MARITAL_STATUS', 'AGE', 'PAY_JULY', 'PAY_AUG', 'PAY_SEP', 'PAY_OCT', 'PAY_NOV', 'PAY_DEC', 'DUE_AMT_JULY', 'DUE_AMT_AUG', 'DUE_AMT_SEP','DUE_AMT_OCT','DUE_AMT_NOV','DUE_AMT_DEC', 'PAID_AMT_JULY', 'PAID_AMT_AUG', 'PAID_AMT_SEP', 'PAID_AMT_OCT', 'PAID_AMT_NOV', 'PAID_AMT_DEC']
X = data[prediction_var]
Y = data.NEXT_MONTH_DEFAULT
test_id= test['Client_ID']
test = test[prediction_var]
# del test['Client_ID']

for i in range(len(X.Balance_Limit_V1)):
  if X.Balance_Limit_V1.at[i] == "1M":
    X.Balance_Limit_V1.at[i] = 1000000
  if X.Balance_Limit_V1.at[i] == "100K":
    X.Balance_Limit_V1.at[i] = 100000
  if X.Balance_Limit_V1.at[i] == "200K":
    X.Balance_Limit_V1.at[i] = 200000
  if X.Balance_Limit_V1.at[i] == "300K":
    X.Balance_Limit_V1.at[i] = 300000
  if X.Balance_Limit_V1.at[i] == "400K":
    X.Balance_Limit_V1.at[i] = 400000
  if X.Balance_Limit_V1.at[i] == " 500K":
    X.Balance_Limit_V1.at[i] = 500000
  if X.Balance_Limit_V1.at[i] == "1.5M":
    X.Balance_Limit_V1.at[i] = 1500000
  if X.Balance_Limit_V1.at[i] == "2.5M":
    X.Balance_Limit_V1.at[i] = 2500000
X.head()

count = 0
for i in range(len(X.Balance_Limit_V1)):
  SUM = X.DUE_AMT_JULY[i]+X.DUE_AMT_AUG[i]+X.DUE_AMT_SEP[i]+X.DUE_AMT_OCT[i]+X.DUE_AMT_NOV[i]+X.DUE_AMT_DEC[i] + X.PAID_AMT_JULY[i]+X.PAID_AMT_AUG[i]+X.PAID_AMT_SEP[i]+X.PAID_AMT_OCT[i]+X.PAID_AMT_NOV[i]+X.PAID_AMT_DEC[i]
  if (SUM == 0):
    X.drop(i, inplace=True)
    # X.drop(X.index[i])
    count = count +1
print(count)

X.dropna()
print(X.shape)

# clean the data
encoder = LabelEncoder()
# encoder.fit(X['Balance_Limit_V1'])
# (X['Balance_Limit_V1']) = encoder.transform(X['Balance_Limit_V1'])
encoder.fit(X['Gender'])
(X['Gender']) = encoder.transform(X['Gender'])
encoder.fit(X['EDUCATION_STATUS'])
(X['EDUCATION_STATUS']) = encoder.transform(X['EDUCATION_STATUS'])
encoder.fit(X['MARITAL_STATUS'])
(X['MARITAL_STATUS']) = encoder.transform(X['MARITAL_STATUS'])
encoder.fit(X['AGE'])
(X['AGE']) = encoder.transform(X['AGE'])


# encoder.fit(test['Balance_Limit_V1'])
# (test['Balance_Limit_V1']) = encoder.transform(test['Balance_Limit_V1'])
encoder.fit(test['Gender'])
(test['Gender']) = encoder.transform(test['Gender'])
encoder.fit(test['EDUCATION_STATUS'])
(test['EDUCATION_STATUS']) = encoder.transform(test['EDUCATION_STATUS'])
encoder.fit(test['MARITAL_STATUS'])
(test['MARITAL_STATUS']) = encoder.transform(test['MARITAL_STATUS'])
encoder.fit(test['AGE'])
(test['AGE']) = encoder.transform(test['AGE'])



encoder.fit(Y)
encoded_Y = encoder.transform(Y)



# converted all the columns to float
X=X.astype(float)
test=test.astype(float)
Y=Y.astype(float)

# standardized the data
sc = StandardScaler()
X = sc.fit_transform(X)
test = sc.fit_transform(test)

from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
os = SMOTE(random_state=0)
os_data_X,os_data_y=os.fit_sample(X, Y)
os_data_X = pd.DataFrame(data=X,columns=prediction_var )
os_data_y= pd.DataFrame(data=Y,columns=['NEXT_MONTH_DEFAULT'])

from sklearn.feature_selection import RFE
from sklearn.linear_model import LogisticRegression
logreg = LogisticRegression()
rfe = RFE(logreg, 20)
rfe = rfe.fit(os_data_X,os_data_y.values.ravel())
print(rfe.support_)
print(rfe.ranking_)

prediction_var_corrected = ['Balance_Limit_V1', 'Gender', 'EDUCATION_STATUS', 'MARITAL_STATUS',  'PAY_JULY', 'PAY_AUG', 'PAY_SEP', 'PAY_OCT', 'PAY_NOV', 'PAY_DEC', 'DUE_AMT_JULY', 'DUE_AMT_SEP','DUE_AMT_OCT','DUE_AMT_DEC', 'PAID_AMT_JULY', 'PAID_AMT_AUG', 'PAID_AMT_SEP', 'PAID_AMT_OCT', 'PAID_AMT_NOV', 'PAID_AMT_DEC']
os_data_X = os_data_X[prediction_var_corrected]
import statsmodels.api as sm
logit_model=sm.Logit(os_data_y,os_data_X)
result=logit_model.fit()
print(result.summary2())

prediction_var_selected = ['Balance_Limit_V1', 'Gender',  'MARITAL_STATUS',  'PAY_JULY', 'PAY_AUG', 'DUE_AMT_JULY', 'PAID_AMT_JULY', 'PAID_AMT_AUG']
os_data_X = os_data_X[prediction_var_selected]
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
X_train, X_test, y_train, y_test = train_test_split(os_data_X, Y, test_size=0.3, random_state=0)
logreg = LogisticRegression()
logreg.fit(X_train, y_train)
y_pred = logreg.predict(X_test)
print('Accuracy of logistic regression classifier on test set: {:.2f}'.format(logreg.score(X_test, y_test)))

test_X = pd.DataFrame(data=test,columns=prediction_var )
test_X = test_X[prediction_var_selected]
y_pred = logreg.predict(test_X)

print

# predicting the test values and downloading the csv file
# Y_test= (rfc.predict(test)>0.5)
ID = pd.DataFrame(test_id, columns = ['Client_ID']) 
REV = pd.DataFrame(rfc_predict, columns = ['NEXT_MONTH_DEFAULT']) 
COLS = [ID,REV]
result = pd.concat(COLS, axis=1)

# encoder.fit(result['Revenue'])
# (result['Revenue']) = encoder.transform(result['Revenue'])
from google.colab import files
result.columns
result.to_csv('Randresult.csv') 
files.download('Randresult.csv')
